syntax = "proto3";

package danube_admin;

// Keep enums/messages consistent with danube/DanubeApi.proto
enum DispatchStrategy {
  NonReliable = 0;
  Reliable = 1;
}

// Retention policy and reliable options are removed in Phase 1; use DispatchStrategy only

service BrokerAdmin {
  // Broker related RPCs
  rpc ListBrokers(Empty) returns (BrokerListResponse);
  rpc GetLeaderBroker(Empty) returns (BrokerResponse);
  rpc ListNamespaces(Empty) returns (NamespaceListResponse);
  rpc UnloadBroker(UnloadBrokerRequest) returns (UnloadBrokerResponse);
  rpc ActivateBroker(ActivateBrokerRequest) returns (ActivateBrokerResponse);
  
  // Load Balancing & Rebalancing RPCs (Phase 3)
  rpc GetClusterBalance(ClusterBalanceRequest) returns (ClusterBalanceResponse);
  rpc TriggerRebalance(RebalanceRequest) returns (RebalanceResponse);
}

service NamespaceAdmin {
  // Namespace related RPCs
  rpc GetNamespaceTopics(NamespaceRequest) returns (TopicListResponse);
  rpc GetNamespacePolicies(NamespaceRequest) returns (PolicyResponse);
  rpc CreateNamespace(NamespaceRequest) returns (NamespaceResponse);
  rpc DeleteNamespace(NamespaceRequest) returns (NamespaceResponse);
}

service TopicAdmin {
  // Topic related RPCs
  rpc ListNamespaceTopics(NamespaceRequest) returns (TopicInfoListResponse);
  rpc ListBrokerTopics(BrokerRequest) returns (TopicInfoListResponse);
  rpc CreateTopic(NewTopicRequest) returns (TopicResponse);
  rpc CreatePartitionedTopic(PartitionedTopicRequest) returns (TopicResponse);
  rpc DeleteTopic(TopicRequest) returns (TopicResponse);
  rpc UnloadTopic(TopicRequest) returns (TopicResponse);
  rpc ListSubscriptions(TopicRequest) returns (SubscriptionListResponse);
  rpc Unsubscribe(SubscriptionRequest) returns (SubscriptionResponse);
  rpc DescribeTopic(DescribeTopicRequest) returns (DescribeTopicResponse);
}

// Common Messages
message Empty {}

message NamespaceRequest {
  string name = 1;
}

message NamespaceResponse {
  bool success = 1;
}

message NewTopicRequest {
  string name = 1;
  optional string schema_subject = 2;  // Schema subject from Schema Registry (optional: topics can have no schema)
  DispatchStrategy dispatch_strategy = 3;
}

message TopicRequest {
  string name = 1;
}

message TopicResponse {
  bool success = 1;
}

message PartitionedTopicRequest {
  string base_name = 1;                    // /namespace/topic
  uint32 partitions = 2;                   // number of partitions
  optional string schema_subject = 3;      // Schema subject from Schema Registry (optional)
  DispatchStrategy dispatch_strategy = 4;
}

message SubscriptionRequest {
  string topic = 1;
  string subscription = 2;
}

message SubscriptionResponse {
  bool success = 1;
}

// Response Messages
message BrokerListResponse {
  repeated BrokerInfo brokers = 1;
}

message BrokerInfo {
  string broker_id = 1;
  string broker_addr = 2;
  string broker_role = 3;
  string admin_addr = 4;
  string metrics_addr = 5;
  string broker_status = 6;
}

message BrokerResponse {
  string leader = 1;
}

message NamespaceListResponse {
  repeated string namespaces = 1;
}

message TopicListResponse {
  repeated string topics = 1;
}

// Detailed topic entry including hosting broker id
message TopicInfo {
  string name = 1;       // /namespace/topic (leading slash)
  string broker_id = 2;  // hosting broker id; empty if unknown/unassigned
  string delivery = 3;   // delivery: Reliable | NonReliable
}

message TopicInfoListResponse {
  repeated TopicInfo topics = 1;
}

// Request to address a specific broker
message BrokerRequest {
  string broker_id = 1;
}

message PolicyResponse {
  string policies = 1;
}

message SubscriptionListResponse {
  repeated string subscriptions = 1;
}

// Describe Topic (schema + subscriptions)
message DescribeTopicRequest {
  string name = 1; // /namespace/topic
}

message DescribeTopicResponse {
  string name = 1;
  repeated string subscriptions = 2;
  string broker_id = 3;
  string delivery = 4;                     // delivery: Reliable | NonReliable
  
  // Schema Registry fields (all optional - topic may have no schema)
  optional string schema_subject = 5;      // Schema subject name
  optional uint64 schema_id = 6;           // Schema ID from registry
  optional uint32 schema_version = 7;      // Schema version
  optional string schema_type = 8;         // "json_schema", "avro", "protobuf", "string", "bytes"
  optional string compatibility_mode = 9;  // "NONE", "BACKWARD", "FORWARD", "FULL"
}

// Broker Unload
message UnloadBrokerRequest {
  // Target broker to unload (string id as published under /cluster/brokers/{broker_id})
  string broker_id = 1;
  // Unload concurrency (default: 1)
  uint32 max_parallel = 2;
  // Optional filters
  repeated string namespaces_include = 3;
  repeated string namespaces_exclude = 4;
  // Dry-run does not perform changes; returns the topics to be affected
  bool dry_run = 5;
  // Per-topic timeout (seconds)
  uint32 timeout_seconds = 6;
}

message UnloadBrokerResponse {
  bool started = 1; // true if accepted/started
  uint32 total = 2;
  uint32 succeeded = 3;
  uint32 failed = 4;
  uint32 pending = 5;
  repeated string failed_topics = 6;
}

// Activate Broker
message ActivateBrokerRequest {
  // Target broker to activate (string id as published under /cluster/brokers/{broker_id})
  string broker_id = 1;
  // Optional reason for auditability
  string reason = 2;
}

message ActivateBrokerResponse {
  bool success = 1;
}

// Load Balancing & Rebalancing (Phase 3)

// Request to get current cluster balance metrics
message ClusterBalanceRequest {}

// Response containing cluster balance metrics
message ClusterBalanceResponse {
  // Coefficient of variation (0.0 = perfectly balanced, higher = more imbalanced)
  double coefficient_of_variation = 1;
  // Mean load across all brokers (typically topic count)
  double mean_load = 2;
  // Maximum load in the cluster
  double max_load = 3;
  // Minimum load in the cluster
  double min_load = 4;
  // Standard deviation of load
  double std_deviation = 5;
  // Number of active brokers
  uint32 broker_count = 6;
  // Detailed broker load information
  repeated BrokerLoadInfo brokers = 7;
  // Assignment strategy currently in use (fair, balanced, weighted_load)
  string assignment_strategy = 8;
}

// Load information for a single broker
message BrokerLoadInfo {
  uint64 broker_id = 1;
  double load = 2;
  uint32 topic_count = 3;
  bool is_overloaded = 4;
  bool is_underloaded = 5;
}

// Request to trigger manual rebalancing
message RebalanceRequest {
  // If true, only calculate and return proposed moves without executing
  bool dry_run = 1;
  // Maximum number of topic moves to execute (default: from config)
  optional uint32 max_moves = 2;
}

// Response from rebalancing operation
message RebalanceResponse {
  // True if rebalancing was successful or dry-run completed
  bool success = 1;
  // Number of moves actually executed (0 for dry-run)
  uint32 moves_executed = 2;
  // Proposed or executed moves
  repeated ProposedMove proposed_moves = 3;
  // Error message if success = false
  string error_message = 4;
}

// A proposed or executed topic move
message ProposedMove {
  string topic_name = 1;
  uint64 from_broker = 2;
  uint64 to_broker = 3;
  double estimated_load = 4;
  string reason = 5;
}