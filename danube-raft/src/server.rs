//! gRPC server-side handler for Raft transport RPCs.
//!
//! Implements the `RaftTransport` trait generated by tonic from `raft_transport.proto`.
//! Deserializes incoming requests, forwards them to the local `Raft` instance,
//! and serializes the responses back.

use openraft::Raft;
use tonic::{Request, Response, Status};

use danube_core::raft_proto::raft_transport_server::RaftTransport;
use danube_core::raft_proto::{
    ClientWriteReply, ClientWriteRequest, NodeInfoReply, RaftReply, RaftRequest,
};

use crate::commands::RaftCommand;

use crate::typ::TypeConfig;

/// Server-side handler for incoming Raft RPCs from peers.
pub struct RaftTransportHandler {
    raft: Raft<TypeConfig>,
    node_id: u64,
    raft_addr: String,
}

impl RaftTransportHandler {
    pub fn new(raft: Raft<TypeConfig>, node_id: u64, raft_addr: String) -> Self {
        Self {
            raft,
            node_id,
            raft_addr,
        }
    }
}

#[tonic::async_trait]
impl RaftTransport for RaftTransportHandler {
    async fn append_entries(
        &self,
        request: Request<RaftRequest>,
    ) -> Result<Response<RaftReply>, Status> {
        let req: openraft::raft::AppendEntriesRequest<TypeConfig> =
            serde_json::from_slice(&request.into_inner().data)
                .map_err(|e| Status::invalid_argument(format!("deserialize failed: {}", e)))?;

        let resp = self
            .raft
            .append_entries(req)
            .await
            .map_err(|e| Status::internal(format!("append_entries failed: {}", e)))?;

        let data = serde_json::to_vec(&resp)
            .map_err(|e| Status::internal(format!("serialize failed: {}", e)))?;

        Ok(Response::new(RaftReply {
            data,
            error: String::new(),
        }))
    }

    async fn vote(&self, request: Request<RaftRequest>) -> Result<Response<RaftReply>, Status> {
        let req: openraft::raft::VoteRequest<u64> =
            serde_json::from_slice(&request.into_inner().data)
                .map_err(|e| Status::invalid_argument(format!("deserialize failed: {}", e)))?;

        let resp = self
            .raft
            .vote(req)
            .await
            .map_err(|e| Status::internal(format!("vote failed: {}", e)))?;

        let data = serde_json::to_vec(&resp)
            .map_err(|e| Status::internal(format!("serialize failed: {}", e)))?;

        Ok(Response::new(RaftReply {
            data,
            error: String::new(),
        }))
    }

    async fn install_snapshot(
        &self,
        request: Request<RaftRequest>,
    ) -> Result<Response<RaftReply>, Status> {
        let req: openraft::raft::InstallSnapshotRequest<TypeConfig> =
            serde_json::from_slice(&request.into_inner().data)
                .map_err(|e| Status::invalid_argument(format!("deserialize failed: {}", e)))?;

        let resp = self
            .raft
            .install_snapshot(req)
            .await
            .map_err(|e| Status::internal(format!("install_snapshot failed: {}", e)))?;

        let data = serde_json::to_vec(&resp)
            .map_err(|e| Status::internal(format!("serialize failed: {}", e)))?;

        Ok(Response::new(RaftReply {
            data,
            error: String::new(),
        }))
    }

    async fn get_node_info(
        &self,
        _request: Request<danube_core::raft_proto::Empty>,
    ) -> Result<Response<NodeInfoReply>, Status> {
        Ok(Response::new(NodeInfoReply {
            node_id: self.node_id,
            raft_addr: self.raft_addr.clone(),
        }))
    }

    async fn client_write(
        &self,
        request: Request<ClientWriteRequest>,
    ) -> Result<Response<ClientWriteReply>, Status> {
        let cmd: RaftCommand = serde_json::from_slice(&request.into_inner().data)
            .map_err(|e| Status::invalid_argument(format!("deserialize command failed: {}", e)))?;

        let resp = self
            .raft
            .client_write(cmd)
            .await
            .map_err(|e| Status::internal(format!("client_write failed: {}", e)))?;

        let data = serde_json::to_vec(&resp.data)
            .map_err(|e| Status::internal(format!("serialize response failed: {}", e)))?;

        Ok(Response::new(ClientWriteReply {
            data,
            error: String::new(),
        }))
    }
}
