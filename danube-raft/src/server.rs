//! gRPC server-side handler for Raft transport RPCs.
//!
//! Implements the `RaftTransport` trait generated by tonic from `raft_transport.proto`.
//! Deserializes incoming requests, forwards them to the local `Raft` instance,
//! and serializes the responses back.

use openraft::Raft;
use tonic::{Request, Response, Status};

use danube_core::raft_proto::raft_transport_server::RaftTransport;
use danube_core::raft_proto::{RaftReply, RaftRequest};

use crate::typ::TypeConfig;

/// Server-side handler for incoming Raft RPCs from peers.
pub struct RaftTransportHandler {
    raft: Raft<TypeConfig>,
}

impl RaftTransportHandler {
    pub fn new(raft: Raft<TypeConfig>) -> Self {
        Self { raft }
    }
}

#[tonic::async_trait]
impl RaftTransport for RaftTransportHandler {
    async fn append_entries(
        &self,
        request: Request<RaftRequest>,
    ) -> Result<Response<RaftReply>, Status> {
        let req: openraft::raft::AppendEntriesRequest<TypeConfig> =
            bincode::deserialize(&request.into_inner().data)
                .map_err(|e| Status::invalid_argument(format!("deserialize failed: {}", e)))?;

        let resp = self
            .raft
            .append_entries(req)
            .await
            .map_err(|e| Status::internal(format!("append_entries failed: {}", e)))?;

        let data = bincode::serialize(&resp)
            .map_err(|e| Status::internal(format!("serialize failed: {}", e)))?;

        Ok(Response::new(RaftReply {
            data,
            error: String::new(),
        }))
    }

    async fn vote(&self, request: Request<RaftRequest>) -> Result<Response<RaftReply>, Status> {
        let req: openraft::raft::VoteRequest<u64> =
            bincode::deserialize(&request.into_inner().data)
                .map_err(|e| Status::invalid_argument(format!("deserialize failed: {}", e)))?;

        let resp = self
            .raft
            .vote(req)
            .await
            .map_err(|e| Status::internal(format!("vote failed: {}", e)))?;

        let data = bincode::serialize(&resp)
            .map_err(|e| Status::internal(format!("serialize failed: {}", e)))?;

        Ok(Response::new(RaftReply {
            data,
            error: String::new(),
        }))
    }

    async fn install_snapshot(
        &self,
        request: Request<RaftRequest>,
    ) -> Result<Response<RaftReply>, Status> {
        let req: openraft::raft::InstallSnapshotRequest<TypeConfig> =
            bincode::deserialize(&request.into_inner().data)
                .map_err(|e| Status::invalid_argument(format!("deserialize failed: {}", e)))?;

        let resp = self
            .raft
            .install_snapshot(req)
            .await
            .map_err(|e| Status::internal(format!("install_snapshot failed: {}", e)))?;

        let data = bincode::serialize(&resp)
            .map_err(|e| Status::internal(format!("serialize failed: {}", e)))?;

        Ok(Response::new(RaftReply {
            data,
            error: String::new(),
        }))
    }
}
